---
title: "Untitled"
keywords: sample homepage
tags: [getting_started]
sidebar: home_sidebar
permalink: index.html
summary: Summary
---

In 1951 book *The Forgotten Language. An Introduction to the Understanding of Dreams*
Erich Fromm, its author tackles the problem od dream interpretation.
He postulates that dream and myths share common structure, a language of sorts.
Drawing from greats like Kant and Freud he proposes his own approach to understanding 
dreams which he lays in terms of translating from symbollic language to a natural one.
The need for understanding the rules of these translations is driven by his belief
(that I also share) that dreams are our subconcious reactions to every day events,
our urges and emotions.

Indirection seems to lie in the very nature of this translations. Seeing your 
father beating your mother may mean violence-related issues, but if there was no
history of violence and non-trivial relation with parents it may as well mean
fear of copying parents mistakes. The more indirect these translations get, the
more abstract and unreal dream seems. Fromms ideas seem to hold when the subject
of interpretation is the dream or myth. Author provides a number of examples,
e.g. deep analysis of Edipus story that reveals much deeper existential crisis
than usual mainstream "hots for mama" interpretation.

I am a programmer for a while now and, as many of other programmers (and people 
doing creative work or being very passionate about it), I had this
incredible experience more than once. 
If I had become immersed enough in a problem I was trying to solve I've often
slept through the night dreaming of that problem and wake with a solution. 
Solution itself always seems to be pretty abstract, yet easily mapped to 
domain-specific language. When figuring out a complex business logic for e-commerce
microservice solution presents itself in terms like "we pass transactions through 
the routing component to handle promotions differently". *Transactions* and *promotions*
come from domain subject language, while *routing component* is part of technical
domain language. Point of the example is to show that domain-specific language
applies both to subject and technology - in functional programming you'll probably
think with monads, in microservices you'll think with microservices, in shops
you'll think about products and in streaming platforms you'll think about sessions
and streams.

It seems that there are 2 kinds of dreams - these that help us solve every day 
issues, handle emotions, urges, instincts and needs, and these that we use to 
solve highly logical and well-organized problems. 
While interpreting the former we usually need a much more indirect translation
than in case of the latter. Size of this discrepancy baffled me for some time now.

My working theory is that regularity of "technical" problems allows for greater
number of patterns than when it comes to "real life" issues. The patterns themselves
are simpler as well. Concepts like "pool" are pretty common, no matter what
the domain or the specifics. On the other hand, reality is much more chaotic.
Patterns that emerge are fuzzier as well. You can see pattern like "speculative
bubble", but they are much harder to explain and even notice. It even gets harder,
because the patterns don't always have to hold (certain pickup line may work 80%
of times, but every 5th time you're out of luck). Level of complication of these
patterns impacts the way that our mind stores it. While I don't even pretend to
understand how the storage happens, I hypothesize (based on my own experiences,
observations and ideas) that it is heavily connection-based and has a lot of 
redundancy. If that would be true, then a natural (yet hard to prove) theory arises:
the more can go wrong when applying the pattern to status quo, the more factors
we need to take into considerations, the more unintuitive indirections we need
to hold it in our mind. The last deduction step here (complication leads to indirection)
seems to resonate with our deep need to look for correlation (even though 
"correlation ain't causation") and experiences with aritificial neural networks
that show that things that intuitively seem very far away may be heavily correlated.

I am not sure what is this thing that you're reading just yet. I don't know
whether to refer to this as an article, a book, a thesis... These few paragraphs
above are a pretty good intro to my mindset. Following chapters will try to
isolate and describe some common patterns that apply when it comes to programming
and computer science in general. 

One could argue that design patterns are just that, but the patterns I'm talking 
about are a bit higher conceptually. A "pool" is a good example of what I mean.
There are a few design patterns, like thread pool, connection pool and lightweight
that share common characteristics ("an abstraction of managing set of instances
to optimize requirements to availability ratio") - these characteristics are
what I will from now on call **concepts**, to avoid confusion with design patterns.

> WIP
